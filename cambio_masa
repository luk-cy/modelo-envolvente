#utilizando los parámetros base, se realiza el calculo de la variación de la envolvente al aumentar la masa del core
resultados = {}

for i, mass_core in enumerate(geomspace(2.98e27, 8.95e27, 10)):
    mypl = planet(mass_core, 6.68e8*(mass_core/4.5e27)**(1/3), disco, tau_double=3.75e12)
    mypl.determine_envelope_mass()
    mypl.info()

    # Guardar los resultados en el diccionario
    resultados[i] = {
        'mass_core': mass_core,  
        'rho_r': mypl.rho_r,
        'M_r': mypl.M_r,
        'P_r': mypl.P_r,
        'T_r': mypl.T_r,
        'radius': mypl.radius,
        'conv_r': mypl.conv_r,
        'luminosity_r': mypl.luminosity_r
    }

    mypl.plot_figures()
    # plt.savefig("figura_" + str(i).zfill(5) + ".png") # guardar figuras

# Guardar los resultados en archivos separados para cada masa en partícular
for i, datos in resultados.items():
    np.savetxt("resultados_masa_" + str(i) + ".csv",
               np.column_stack([datos['radius'], datos['rho_r'], datos['M_r'], datos['P_r'], datos['T_r'], datos['conv_r'], datos['luminosity_r']]),
               header="radius rho_r M_r P_r T_r conv_r luminosity_r")

#ffmpeg -i figura_%05d.png out.mp4
def encontrar_radio_conv_1(radius, conv_r):
    # Convertimos los datos a arrays de numpy
    radius = np.array(radius)
    conv_r = np.array(conv_r)
    
    # Encontrar índices donde conv_r cruza el valor 1
    indices_cercanos = np.where((conv_r[:-1] < 1) & (conv_r[1:] > 1) | (conv_r[:-1] > 1) & (conv_r[1:] < 1))[0]

    if len(indices_cercanos) > 0:
        # Valores de conv_r y radio en los puntos cercanos al primer cruce
        idx = indices_cercanos[0]  # Tomar solo el primer cruce
        x0, x1 = conv_r[idx], conv_r[idx + 1]
        y0, y1 = radius[idx], radius[idx + 1]
        
        # Interpolación lineal para encontrar el radio donde conv_r = 1
        f_interp = interp1d([x0, x1], [y0, y1], assume_sorted=False)
        radio_interp = f_interp(1)  # conv_r = 1
        return radio_interp
    else:
        return None  # No se encontró un cruce

# Guardar los radios interpolados en archivos CSV
for i, datos in resultados.items():
    radio_conv_1 = encontrar_radio_conv_1(datos['radius'], datos['conv_r'])
    
    # Guardar en archivo CSV si se encuentra un radio interpolado
    if radio_conv_1 is not None:
      mass_core = datos['mass_core'] 
      np.savetxt("radio_conv_masa_" + str(i) + ".csv",
                   [mass_core, radio_conv_1],
                   header="masa radius")
